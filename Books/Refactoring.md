![img](C:\SAPShare\Chainnotes\Assets\books\webp)

重构（第二版）重构成js版，是程序员必读书单中的一本，相较于（第一版）Java版，更适合前端阅读。

本书作者 马丁·福勒（Martin Fowler），主要著作有：[分析模式 : 可复用的对象模型](https://book.douban.com/subject/35231629/)、Kent Beck. 规划极限编程、 [UML精粹 : 标准对象建模语言简明指南](https://book.douban.com/subject/10798193/)、 [企业应用架构模式](https://book.douban.com/subject/4826290/)以及本书。

本书内容以各种代码的“坏味道”，来推进合适的重构手法，和第一版内容相比，有一些部分是更新了（那些被淘汰的代码、不合适的例子）。但主体思想，底层核心没有变，总而言之是本值得读的好书。





# WHAT: 什么是重构（Refactoring）？

> 重构（名词）：对软件内部结构的一种调整，目的是**在不改变软件可观察行为的前提下**，提高其可理解性，降低修改成本。
>
> 重构（动词）：使用一系列重构的手法，**在不改变软件可观察行为的前提下**，调整其结构。

一种特定的代码清理方式，关键在于运用**大量**、**微小**、且保持软件行为的步骤，一步步达成大规模的修改。



**大量**、**微小** ? 指单独的每个重构要么scope很小，要么是由很多小步骤组成 （=一大步）=> 更快，整个过程不花任何时间调试



## **重构** vs. **重写**

代码很少进入不可工作的状态，即使重构未完成，也可以在任何时刻停下来

> 如果有人说他们的代码在重构过程中有1-2天时间不可用，基本上可以确定，他们在做的事情不是重构。

如果重写比重构容易，就别重构了。花一点点时间去真实了解重构一块代码的难度，再决定到底应该重构还是重写。



## **重构** vs. **性能优化**

相同点：都需要修改代码，且都不会改变程序的整体功能。

不同点：重构为了让代码更容易理解，更易于修改，性能上可能变快也可能变慢；性能优化只关心让程序跑得更快，不在乎最终代码的可读性及可维护性。

重构可以帮助开发人员写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的结果。



## 总结

所谓重构（refactoring）是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后持续改进它的设计。



------

# WHY: 为何要重构？

书中开始用一个例子简单阐释为什么要重构，以及重构的好处。如果没有重构，程序就会腐败变质，程序逐渐失去自己的结构，

```
越来越难通过读源码理解设计，不好的/重复的/代码不便于后来的修改和阅读。
```

重构可以深入理解代码并且帮助找到bug

```
同时重构可以减少bug引入的机率，方便日后扩展。
提高可理解性
降低修改成本
```

提高编程的速度，良好的设计 => 快速开发的根本

```
 提高质量，从而提高开发速度。
 反直觉，把目光放大到整个项目（开发、维护）周期。
```

## 总结

- **重构**改进软件的设计（/架构）=> 质量↑
- **重构**使软件更容易理解            => 质量↑
- **重构**帮助找到Bug                    => 质量↑
- **重构**提高编程速度                   => 速度↑



------

# WHEN: 什么时候重构？

引用书中一段话：

> 第一次做某件事时只管去做，第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。
>
> 三次法则，事不过三，三则重构。

也就是说当我们做相同的事情第三遍的时候，就应该去重构了。

## **1.预备性重构**：让添加新功能更容易

如书中所说，当需要添加新功能时，我们应该先去看看现有的代码库，可能现在添加的功能在现有的函数里已有实现了大部分，只需要改动很小的部分就可以，那么这个时候，就可以先戴上重构的帽子，将代码进行重构，然后再当完成新的功能就变得很简单。

> 作者在书中用一个小故事来说明这个道理：
> 就好比你需要往东去100公里，我不会往东直接开，而是先往北开20公里上高速，在往东开100公里。

我们总是想着, 找个时间重构, 其实, 重构更应该放在平时, 每一次去变更代码时处理. 毕竟, 所谓的重构契机有时候太过遥远; 而如果不做重构, 痛苦的是每时每刻维护代码的自己

> 如果你发现自己需要为程序添加一个特性, 而代码结构使你无法很方便地达成目的, 那就先重构那个程序, 使特性的添加比较容易进行, 然后再添加特性

另外, 如果可能, 尽量加单元测试, 重构的第一步就是建立一个有效的测试机制，好的测试机制可以帮助重构。哪怕一次只增加一两个, 一段时间后, 你会发现, 你会感谢过去的自己。



## **2.帮助理解的重构**：使代码更易懂

当我们看代码时，脑海里会形成一些理解，我们把这些理解转移到代码本身，这会让这份知识或理解保存的更久远，例如看到一个糟糕的逻辑，一个糟糕的命名，当理解这些代码时，快速的将其重构，这样后面当你或者其他同事再来看这段代码将变得简单。



## **3.捡垃圾式重构**

帮助理解的重构的一个变体：已经理解代码在做什么，但发现做得不够好。

《Clean code》中提及的童子军法则：“离开的时候，总要让露营地比你来的时候更干净。” 如果你在地上发现脏乱，把它收拾了，无论是谁造成的。

代码亦是如此。重构的妙处也在此。



## **4.有计划的重构和见机行事的重构**

以上1.2.3.都是见机行事的重构，也就是不专门安排一段时间去做重构，而是在添加功能/修复bug的同时顺便重构。是自然的编程过程中的一部分。

有计划的重构： diagram、table... 专门花些时间只做重构工作。但有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。

> “肮脏的代码需要重构，但漂亮的代码也需要很多重构”

​	长期重构：有一些大型重构可能要花上几个星期，甚至几个月。比如：替换一个正在使用的库 / 抽取代码到组件中共享给其他团队 / 处理一大堆混乱的依赖关系



## **5.复审代码时重构**

![code review](C:\SAPShare\Chainnotes\Assets\books\code-review.png)

复审代码也就是我们常说的code review，或者结对编程时，这种活动可以改善开发状况，还有助于在开发团队中传播知识，也有助于把知识传递给经验欠缺的人员。

代码复审也可以让更多人有机会提出有用的建议，毕竟一个开发在一周内能想到的好点子有限，如果能得到别人的帮助，那生活会滋润许多。

在这个过程中我们还可以看到代码中的不足，进而通过重构的手段来快速的解决这个问题，并且重构能够帮助复审代码工作得到具体的结果，不仅能当场获得建议，而且许多建议能够立刻实现。

如何在Review中加入重构，这取决于Review的形式。



## 总结

**需要重构**

1. 三次法则，遇三重构。
2. 重构的最佳时机就是在添加新功能之前。
3. 重构的前提是理解代码，重构使代码更容易理解。
4. 看见不够好的代码/命名，随手就重构它。
5. 有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。
6. 在Code Review中加入重构。

**不需要重构**

1. 不需要修改的代码
2. 隐藏在一个API下的，只有当需要理解其工作原理时，对其进行重构才有价值
3. 重写比重构还容易




------

# 重构的时机 

<img src="C:\SAPShare\Chainnotes\Assets\books\v2-9710d10d35fe4043708ca479879badef_r.jpg" alt="preview" style="zoom:50%;" />

代码的坏味道：也是本书的核心之一，简单来说就是碰到什么样子的代码，你就需要警惕起来，需要进行重构了。

这里只讲现象，不讲解决的重构手法，本书后2/3会详细阐述各个手法的应用。



## **神秘命名**

​	命名是编程中最难的两件事情之一。

​	想不出一个好名字，意味着背后有可能潜藏这更深的设计问题。而一个好名字意味着你一眼就能直接明白其意图，或设计想法

​    为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

```cpp
public bool ValidateUser(long userId)
{
    int userScore = 100;

    bool b = CheckYCDYCondition(userId);
    if (!CheckCondition1(userId)) userScore -= 30;
    if (!CheckCondition2(userId)) userScore -= 40;

    if (b == true) 
         goto end;
    if (b == false)
         return false;

:end
    return userScore >= 60;
}
```



## **重复代码**

![image-20210623140217737](C:\SAPShare\Chainnotes\Assets\books\image-20210623140217737.png)

如果你在一个以上的地方看到相同的代码结构，那么可以肯定，设法将它们合二为一，程序会变得更好。



**过长函数**

​	函数越长，越难理解

​	小函数易于理解的关键还是在于良好的命名。

过长的参数列表

过长的消息链

## 过大的类

单个类做了过多的事情，其内部往往会出现太多字段，一旦如此，重复代码也就接踵而至。这也意味着这个类绝不只是在为一个行为负责



## 异曲同工的类

两个可以相互替换的类，只有当接口一致才可能被替换



## 纯数据类

拥有一些字段以及用于读写的函数，除此之外一无是处的类，一般这样的类往往半一定被其他类频繁的调用（如果是不可修改字段的类，不在此列，不可修改的字段无需封装，直接通过字段取值即可），这样的类往往是我们没有把调用的行为封装进来，将行为封装进来这种情况就能得到很大改善。



## 全局数据

最常见的就是全局变量，但类变量与单例模式也有这样的问题，我们通常无法保证项目启动后不被修改，这就很容易造成诡异的bug，并且很难追查到



## 可变数据

数据的可变性和全局变量一样，如果有其他使用者修改了这个值，而引发不可理喻的bug。 这是很难排查的。



## 发散式变化

发散式变化是指某个模块经常因为不同的原因在不同的方向上变化了（可以理解为某一处修改了，造成其他模块方向错乱）



## 霰弹式修改

和发散式变化接近，却又相反。我们每次修改一个功能或者新增一个功能都需要对多处进行修改；并且随着功能增多我们可能还需要修改更多。 



## 依恋情结

一个模块内的一部分频繁的和外面的模块进行交互沟通，甚至超过了它与内部的沟通。也就是违反了高内聚低耦合，遇到这种的“叛乱者”，不如就让他去他想去的地方吧



## 数据泥团

总是绑在一起出现的数据。代码中也如是，我们可能经常看到三四个相同的数据，两个类中相同字段等等。



## 基本类型偏执

一些基本类型无法表示一个数据的真实意义，例如把钱、坐标、范围等当作普通数字，电话号码当作字符串。



## 重复的Switch

![image-20210623140256784](C:\SAPShare\Chainnotes\Assets\books\image-20210623140256784.png)

不只是switch，大片相联的if也应该包含在内，甚至在古老的前端时代，曾经一度无条件反对这样的写法。



## 循环语句

![image-20210622171350975](C:\SAPShare\Chainnotes\Assets\books\image-20210622171350975.png)

这里指利用管道操作（forEach, map, filter, reduce）来替代传统的 for / while 循环。



## 冗赘的元素

元素指类和函数，但是这些元素可能因为种种原因，导致函数过于小，导致没有什么作用，以及那些重复的，都可以算作冗赘



## 夸夸其谈通用性

为了将来某种需求而实现的某些特殊的处理，但其实可能导致程序难以维护难以理解



## 临时字段

那些本身就足以说明自己是谁的，不需要名字来描述的



## 中间人

如果一个类有大部分的接口（函数）委托给了同一个调用类。当过度运用这种封装就是一种代码的坏味道



## 内幕交易

两个模块的数据频繁的私下交换数据（可以理解为在程序的不为人知的角落），这样会导致两个模块耦合严重，并且数据交换隐藏在内部，不易被察觉



## 被拒绝的遗赠

这种味道比较奇怪，说的是继承中，子类不想或不需要继承某一些接口，我们可以用函数下移或者字段下移来解决，但不值得每次都这么做。

只有当子类复用了超类的行为却又不愿意支持超类的接口时候我们才应该做出重构。



## 注释

这里提到注释并非是说注释是一种坏味道，只是有一些人经常将注释当作“除臭剂”来使用（一段很长的代码+一个很长的注释，来帮助解释）。往往遇到这种情况，就意味着：我们需要重构了



------

# 第一组重构

## 6.1 提炼函数

1． When

- 代码长度：一个函数应该能在一屏中显示
- 代码复用：被用过不止一次的代码就应该放进一个单独的函数
- “将意图与实现分开”：当需要一段时间才能读懂一段代码时，就应该考虑提炼，并根据其用途命名。

2． How

1. 以“做什么”来命名新函数，而非“怎么做”
2. 提炼代码
3. 检查作用域，新函数中访问不到的变量以参数形式传入
4. 编译
5. 将原函数中被提炼的部分替换成新函数
6. 测试
7. 检查其他地方是否还有相同或相似的逻辑。若有，则考虑替换

3．Note

- 大量函数调用影响性能？  A:     短函数更能体现编译器的优化功能，因为段函数可以更容易被缓存
- 命名至关重要，一个好的名字可以让人一眼就看出这个函数的作用



## 6.2 内联函数

1． When

- 函数内部代码和其名称一样清晰易读。 E.g.

```js
// Before
function getRanting(driver) {
    return moreThanFiveLateDeliveries(diver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(diver) {
	return (diver.numberOfLateDeliveries > 5) ? 2: 1;
}

// After
function getRanting(driver) {
    return (diver.numberOfLateDeliveries > 5) ? 2: 1;
}
```

- 将一群不合理的函数内联到一个大函数里，再进行提炼
- 如果代码中间有太多间接层，导致每个函数似乎都只是对另一个函数的委托，使得代码可读性变差。可以通过内联函数去除无用的间接层

2． How

1. 确认函数不具备多态性：若一个函数属于某个类，且有子类继承了该函数，则该函数无法内敛
2. 确认该函数的所有调用点
3. 将所有调用点替换为函数本体
4. 测试
5. 删除该函数定义

3． Note

- 始终小步进行，且保证每次改动都能通过所有测试用例



## 6.3 提炼变量

```js
// Before
Function price (order) {

	// price is base price – quantity discount + shipping
	return order.quantity * order.itemPrice – Math.max(0, order.quantity – 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100);
}

// -> After

Function price(order) {
	const basePrice = order.quantity * order.itemPrice;
	const quantityDiscount = Math.max(o, order.quantity – 500) * order.itemPrice * 0.05;
	const shipping = Math.min(basePrice * 0.1, 100);
	return basePrice – quantityDiscount + shipping;
}
```

1. When

表达式比较长，难以阅读

 

2. How

1. 声明一个不可修改的变量，复制想要提炼的表达式并把结果值给这个变量
2. 用新变量取代原来的表达式

 

3. Note

如果提炼需要适用整个类，而不仅仅是在函数代码上下文内，可以提炼成方法

 



## 6.4 内联变量

（上一节，提炼变量的反向重构）

```js
let basePrice = anOrder.basePrice;
return (basePrice > 1000);

->

return anOrder.basePrice > 1000;
```



1. When

变量并不能比表达式本身更具有表现力

 

2. How
1. 检查确认变量赋值语句的右侧表达式没有副作用
2. 确保该变量只被赋值一次
3. 逐一替换所有使用该变量的地方
4. 删除该变量的声明点和赋值语句



## 6.5 改变函数声明

```js
// 例子1 (修改函数声明)： 
function circum (radius) {                                                       
    return circumference (radius); 
}
function circumference (radius) {                                                       
    return 2 * Math.PI * radius; 
}
//创建完circumference函数之后，然后耐心等客户端改用circumference函数，等他们都改完了，再删除circum函数
```

```js
// 例子2 (添加函数参数)： 
class Book ..
addReservation(customer) {
    this._reservations.push(customer);
}

//Step1：
//提炼函数，把addReservation函数体提炼出来，放进一个新的函数，新函数也叫 addReservation 但新旧2个函数不能重名，
//所以先临时给新函数起个容易搜索到的名字
class Book ..
addReservation(customer) {
    this._reservations.push(customer);
}

zz_addReservation(customer) {
    this._reservations.push(customer);
}

// Step2
// 新函数的声明中增加参数，同时修改旧函数调用新函数的地方
class Book ..
addReservation(customer) {
    this.zz_addReservation(customer, false);
}

zz_addReservation(customer, _isPriority) {
    this._reservations.push(customer);
}

// Step3
// 引入断言，确保调用方一定会用到这个新参数
class Book ..
addReservation(customer) {
    this.zz_addReservation(customer, false);
}

zz_addReservation(customer, isPriority) {
    assert(isPriority === true || isPriority === false);
    this._reservations.push(customer);
}

// Step4
// 现在只要在调用方漏了参数，断言会帮忙抓到错误, 保证了调用新函数的正确
// 使用内联函数，确保调用方都使用新的函数
// 最后，把新函数改回原来的名字
class Book ..
addReservation(customer, isPriority) {
    assert(isPriority === true || isPriority === false);
    this._reservations.push(customer);
}
```

When:

​        函数名含糊不清，不能准备表达其行为

​        函数参数不清晰导致函数逻辑不必要的耦合



How

​        简单做法：

1． 修改函数名， 或者增减函数参数 （两者最好分两步来做）

2． 找到所有调用旧函数的地方，将它们改为使用新的函数

3． 测试

 

​       迁移式做法：

1． 使用提炼函数的方法将函数体提炼成一个新的函数

2． 测试

3． 对旧函数使用内联函数

4． 测试



## 6.6 封装变量

   When:

  如果想要搬移一处被广泛使用的数据，最好的办法就是先以函数形式封装所有对该数据的访问，这样我们就可以把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务

 

​    How 

1. 创建封装函数，在其中访问很更新变量值
2. 执行静态检查
3. 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试
4. 限制变量的可见性
5. 测试



 

##  6.7 变量改名

```js
//给常量改名：
Const cpyNm = "Acme Gooseberries"

//复制这个常量，有了副本，就可以逐一修改引用旧常量的代码
Const companyName = "Acme Gooseberries"
Const cpyNm = companyName
```

1. When

- 当时想的不够仔细
- 对问题的理解加深
- 程序用途随着用户需求改变

2. How

1. 如果变量被广泛使用，考虑将其封装
2. 找到所有使用变量的代码，逐一修改     (Note: 如果变量值从不修改，可以将其复制到新名字下，逐一修改，每次修改后测试)
3. 测试



## 6.8 引入参数对象

```js
// Before
function amountInvoiced (startDate, endDate){…}
function amountReceived(startDate, endDate){…}
function amountOverdue (startDate, endDate){…}

// After
function amountInvoiced (aDateRange){…}
function amountReceived(aDateRange){…}
function amountOverdue (aDateRange){…}
```



1. When

   一组数据总是结伴同行，出没于一个又一个函数，这样一组数据就是所谓的数据泥团，考虑将其组织成数据结构

2. How
   1. 创建数据结构
   2. 测试
   3. 使用“改变参数声明”给原来的函数一个新的参数，类型是新建的数据结构
   4. 测试
   5. 调整所有调用者，传入新数据结构的适当实例，每修改一处执行测试
   6. 用新数据结构的每项元素逐一取代参数列表中对应的参数项，然后删除原来的参数，测试
















---
重构的原则

- 小步前进, 频繁测试
- 隔离变化
- 控制可见范围, 让变量/常量/函数/类等, 在最小的范围内可见. 例如设为私有变量/私有函数, 移除不必要的设值函数
- 重构时, 不要关注性能. 到性能优化阶段, 再关注性能. 不同阶段关注点不一样, 不要过早优化. 很多时候, 性能并不是瓶颈, 可读性和可维护性更重要
- 任何时候, 都不要拷贝代码, 拷贝类, 甚至拷贝源码文件
  
  ------
  
  **2，重构原则**
  
  ```
  
  ```
  
  **重构小技巧：**
  
  ```
  - 允许逻辑共享 
  - 分开解释意图或实现 
  - 隔离变化 例如一个类需要在2个地方使用，可以使用子类来处理变化 4）封装条件逻辑
  
  2.2， 重构与设计
  前提简单可行的设计（不一定要完全正确）， 重构可以预先取代设计，先把功能做好 然后重构 “极限编程” 支持这种观点，证明这种方法可行
   2.3，重构与性能
   时间预算 持续关注法（深度理解代码，并且知道哪些地方耗费时间）
   性能优化案例：
   大字符串操作耗费性能？
   字符串缓存起来 - 改用文件流处理 - 多处理器计算机，多线程 系统从运算1000个小时 到 2个小时的飞速提升
   
  ```
  
  ------
  
  **3，代码坏味道**
  
  ```
  重复代码
   - 同一个类 2个函数有相同的表达式 
   - 兄弟子类有相同的表达式 
   - 2个独立的类有相同的代码
  3.2 函数过长
  分解函数的原则：每当感觉需要注释说明点什么的时候，我们需要把需要说明的东西写到一个独立的函数中，并以其用途来命名。如果代码前面有一条注释，就说明这个地方需要提炼出一个函数。
  
  条件表达式（多个if else 改成三元表达式 Decompose Conditional） 和循环也是提炼的信号，
  循环可以提炼到一个单独的函数中。
  
   3.3 过大的类 --解决重复代码的问题
   3.4 过长的参数列，建议使用参数对象，传递一个参数。
   3.5 发散式变化（一个类受到多种变化的影响），散弹式修改 一个变化引发多个类修改
   解决经常被修改的类，将经常需要修改的变量字段提炼到一个独立的类。
  
   3.6 依恋情节 数据和数据操作包装在一起 原则：将总是一起发生变化的东西放在一起。
   3.7 数据泥团 类中有相同的属性 函数中有类似的参数 删除一个不影响这个类或者函数的意义，建议拆分新对象 减少字段或者参数的个数
   3.8，switch statement
  大多情况下 出现switch语句 就应该考虑多态来替换，这样的switch需要提炼到一个独立的函数并且将它放到需要处理的类中。
   3.9 平行继承 目的在于消除类之间的重复代码。
   3.10 冗赘类 无用的代码类。
   3.11 暂时使用的字段 只有执行某个代码块才有意义的字段  抽到一个独立的类中
   3.12 过多的注释 试图用函数提炼代码，删除注释
  ```
  
  **4，构建测试体系**
  
  ```
  意义：一套测试就是一个强大的bug监听器 能够大大减少bug查找时间
  建立一个独立的类用于测试并且在框架中运用它，使测试工作更加轻松
  4.1 Junit 测试框架的运用
  每收到一个bug，先写一个单元测试来暴露bug，考虑可能出错的边界条件，把测试的重点集中在那
  ```
  
  **5 重构列表**
  **6.重构函数**
  
  ```
  重构的大部分集中在函数的重构，参数的重构
   内联函数 去除间接层
  1，不要对参数赋值（Java 1.1 允许将参数定义为final）。 
  2，如果临时变量被多次赋值，应该分解多个独立的临时变量 
  3，分析临时变量是否被公用，把这个临时变量提炼到一个函数中（Replace temp with query） 
  4，临时变量用于分解复杂的表达式 
  5，替换算法，将比较复杂的算法替换成简单的 易懂的（或者将大的算法分成小部分 易于理解，然后寻找小算法的替换方案）
  ```
  
  ------
  
  **7，对象之间的搬移特性**